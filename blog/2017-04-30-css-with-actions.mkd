# CSS is working now

## CMake

CMake made all the dependencies nice. The source files are:

 * [/src/parser/css.machine.rl](https://github.com/matiu2/cdnalizer/blob/master/src/parser/css.machine.rl) -- contains the state machine definition
 * [/src/parser/css.hpp.rl](https://github.com/matiu2/cdnalizer/blob/master/src/parser/css.hpp.rl) -- Contains the C++ template code

In CMake we use `cmake_custom_command`, along with `add_custom_target` to make everything work smoothly.

### Visualizations of the state machines

Firstly we need to generate pretty pictures like this state machine:

![css state machine](css_state_machine.png)

To do this we use these two blocks in CMakeLists.txt

    # Update the blog directory with the latest css state machine pic
    add_custom_command(
        OUTPUT ${CMAKE_CURRENT_SOURCE_DIR}/../../blog/css_state_machine.png
        PRE_BUILD
        COMMAND ragel -Vp ${CMAKE_CURRENT_SOURCE_DIR}/css.machine.rl | dot -Tpng -o ${CMAKE_CURRENT_SOURCE_DIR}/../../blog/css_state_machine.png;
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/css.machine.rl
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )

This tells CMake, "to make the file ../blog/css_state_machine.png, require css.machine.rl, and run this ragel command to generate it".

Next we incorporate that into the build with this block:

    add_custom_target(parser_visualization 
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/../../blog/css_state_machine.png)

Here we're adding a make target called `parser_visualization` which depends on the png above existing.

CMake is smart enough so that if the `css.machine.rl` is newer than the `css_state_machine.png` and you call that make target, it'll make it (otherwise it'll do nothing).

### Actual code

The other part of the dependency is generating [css.hpp](https://github.com/matiu2/cdnalizer/blob/master/src/parser/css.hpp), the actual C++ code.

In [/src/parser/CMakeLists.txt](), we tell cmake how to create `css.hpp`:

    # Generate css.hpp source from the ragel template
    add_custom_command(
        OUTPUT ${CMAKE_CURRENT_SOURCE_DIR}/css.hpp
        PRE_BUILD
        COMMAND ragel -C -o ${CMAKE_CURRENT_SOURCE_DIR}/css.hpp ${CMAKE_CURRENT_SOURCE_DIR}/css.hpp.rl;
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/css.hpp.rl
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/css.machine.rl
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )

Then we add a target that depends on `css.hpp` existing, so if you build that target, and `css.hpp` is older than `css.hpp.rl` or `css.machine.rl`, it'll regenerate `css.hpp`.

    add_custom_target(parser_code_generated
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/css.hpp)

Finally we tie that custom_target in with the base library in [/src/CMakeLists.txt](https://github.com/matiu2/cdnalizer/blob/master/src/CMakeLists.txt#L7):

    add_dependencies(base parser_code_generated)

# Code

The beautiul code generated by ragel, uses a tight loop, gotos, table lookups
and switch statements to get the job done. When you trace through it with gdb,
you can add a hardware watch point to `cs` (current state); it is an integer
and matches the states in the diagram, so you can see exactly where you are.

[Here's the generated parser code](https://github.com/matiu2/cdnalizer/blob/master/src/parser/css.hpp)

# State machine actions

I've added two actions to the state machine:

    action rec_start {
      css_start = p;
    }

    action rec_end {
      path_found(css_start, p);
    }

The first one is triggered when it finds the start of a path that may need rewriting, and the second is triggered at the end of that path. You can see them being triggered in the diagram at **/rec_start**  and **/rec_end**:

![css state machine](css_state_machine.png)

`rec_start` just copies the iterator/pointer so we know where the path started.

`rec_end` calls a callback function. In our caller we have Apache split up the
bucket and send all previous data down the line if we had to rewrite the path.
We also change `p` (current position) and `pe` (pointer to the end) so that the
parser can just carry on working as if nothing had changed.

----

Now I'll get to work on the HTML parser and JS parser, then do some more speed tests.
